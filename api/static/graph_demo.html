<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Genealogy Graph Demo</title>
  <style>
    :root {
      --bg: #0b0f16;
      --panel: #121a27;
      --panel2: #0f1622;
      --text: #e8eefc;
      --muted: #a6b4d6;
      --accent: #7aa2ff;
      --danger: #ff6b6b;
      --border: rgba(255,255,255,0.08);
      --shadow: 0 12px 32px rgba(0,0,0,0.45);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 600px at 25% 10%, rgba(122,162,255,0.18), transparent 55%),
                  radial-gradient(900px 500px at 80% 30%, rgba(255,107,107,0.10), transparent 50%),
                  var(--bg);
      color: var(--text);
      font-family: var(--sans);
    }

    .app {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    header {
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(18,26,39,0.95), rgba(18,26,39,0.70));
      backdrop-filter: blur(6px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .brand {
      display: flex;
      gap: 10px;
      align-items: baseline;
      margin-right: 10px;
    }

    .brand h1 {
      margin: 0;
      font-size: 16px;
      font-weight: 700;
      letter-spacing: 0.2px;
    }

    .brand .sub {
      font-size: 12px;
      color: var(--muted);
    }

    .panel {
      background: rgba(15,22,34,0.75);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      box-shadow: var(--shadow);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: end;
    }

    label {
      display: grid;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
    }

    input, select {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(9, 13, 20, 0.75);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      min-width: 140px;
      outline: none;
    }

    input[type="number"] { min-width: 90px; }

    input:focus, select:focus {
      border-color: rgba(122,162,255,0.55);
      box-shadow: 0 0 0 4px rgba(122,162,255,0.12);
    }

    button {
      border: 1px solid rgba(122,162,255,0.45);
      background: rgba(122,162,255,0.12);
      color: var(--text);
      border-radius: 10px;
      padding: 9px 12px;
      cursor: pointer;
      transition: transform 0.06s ease, background 0.12s ease;
    }

    button:hover { background: rgba(122,162,255,0.18); }
    button:active { transform: translateY(1px); }

    button.secondary {
      border-color: rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
    }

    button.danger {
      border-color: rgba(255,107,107,0.50);
      background: rgba(255,107,107,0.12);
    }

    .hint {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }

    .hint code {
      font-family: var(--mono);
      font-size: 11px;
      padding: 1px 6px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.35);
      border-radius: 8px;
      color: #cfe0ff;
    }

    .status {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.25);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
    }

    main {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
      padding: 12px;
    }

    #cy {
      height: 100%;
      width: 100%;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(3, 6, 10, 0.65);
      box-shadow: var(--shadow);
      position: relative;
    }

    .legend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .chip {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-size: 12px;
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--muted);
      display: inline-block;
    }

    .dot.person { background: #7aa2ff; }
    .dot.private { background: #ffb86c; }
    .dot.family { background: #9d7bff; }
    .dot.partner { background: #7ce38b; }
  </style>

  <script src="https://unpkg.com/cytoscape@3.27.0/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
  <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
</head>
<body>
  <div class="app">
    <header>
      <div class="row">
        <div class="brand">
          <h1>Genealogy Graph Demo</h1>
          <div class="sub">switch family-hub vs direct edges</div>
        </div>

        <div class="panel" style="flex: 1; min-width: 300px;">
          <div class="controls">
            <label>
              Person ID
              <input id="personId" value="I0001" placeholder="I0001 or _handle" />
            </label>
            <label>
              Generations
              <input id="depth" type="number" min="0" max="12" value="2" />
            </label>
            <label>
              Max nodes
              <input id="maxNodes" type="number" min="1" max="5000" value="1000" />
            </label>
            <label>
              Layout
              <select id="layout">
                <option value="graphviz">graphviz (dot) — best layout</option>
                <option value="family">family hubs (Cytoscape dagre)</option>
                <option value="direct">direct edges</option>
              </select>
            </label>

            <button id="loadBtn">Load</button>
            <button class="secondary" id="fitBtn">Fit</button>
            <button class="secondary" id="toggleBtn" title="Quick toggle family/direct">Toggle</button>
            <button class="secondary" id="pngBtn">Export</button>
          </div>
          <details style="margin-top: 10px;">
            <summary style="cursor: pointer; color: var(--muted); font-size: 12px;">Options</summary>
            <div class="row" style="margin-top: 10px; gap: 14px; flex-wrap: wrap;">
              <label style="grid-auto-flow: column; align-items: center; gap: 8px;">
                <input id="optCouplePriority" type="checkbox" checked />
                Couple priority
              </label>
              <label style="grid-auto-flow: column; align-items: center; gap: 8px;">
                <input id="optShowIds" type="checkbox" />
                Show Gramps IDs (debug)
              </label>
              <label style="grid-auto-flow: column; align-items: center; gap: 8px;">
                <input id="optShowDistance" type="checkbox" />
                Show distance (BFS hops)
              </label>
              <label>
                Dates
                <select id="optDateStyle" style="min-width: 210px;">
                  <option value="full">Full (stacked)</option>
                  <option value="compact">Years (compact)</option>
                </select>
              </label>
              <div class="hint" style="max-width: 720px;">
                Birth/death (* / †) and marriage (⚭) are always shown when available.
              </div>
            </div>
          </details>
          <div class="row" style="margin-top: 8px; gap: 12px;">
            <div class="hint">
              API: <code>/graph/neighborhood</code> · Try <code>I0001</code>. Tip: <code>graphviz</code> layout uses the same DOT-style approach as Gramps Web.
            </div>
          </div>
        </div>
      </div>
    </header>

    <main>
      <div class="row" style="justify-content: space-between;">
        <div class="legend">
          <span class="chip"><span class="dot person"></span> Person</span>
          <span class="chip"><span class="dot private"></span> Private</span>
          <span class="chip"><span class="dot family"></span> Family hub</span>
          <span class="chip"><span class="dot partner"></span> Partner edge (direct layout)</span>
        </div>
        <div style="display:flex; gap:10px; align-items:center; justify-content:flex-end; flex-wrap:wrap;">
          <div id="apiNotice" class="status" style="display:none; border-color: rgba(255,184,108,0.35); color: #ffb86c;">API notice</div>
          <div id="status" class="status">Ready.</div>
        </div>
      </div>

      <div id="cy"></div>
      <div id="gv" style="display:none;"></div>
    </main>
  </div>

<script type="module">
  // Register dagre layout plugin.
  if (window.cytoscape && window.cytoscapeDagre) {
    cytoscape.use(window.cytoscapeDagre);
  }

  import { Graphviz } from 'https://unpkg.com/@hpcc-js/wasm-graphviz@1.18.0/dist/index.js';

  const statusEl = document.getElementById('status');
  const apiNoticeEl = document.getElementById('apiNotice');
  const gvEl = document.getElementById('gv');
  const personIdEl = document.getElementById('personId');
  const depthEl = document.getElementById('depth');
  const maxNodesEl = document.getElementById('maxNodes');
  const layoutEl = document.getElementById('layout');

  let gvPanZoom = null;

  const optShowIdsEl = document.getElementById('optShowIds');
  const optShowDistanceEl = document.getElementById('optShowDistance');
  const optCouplePriorityEl = document.getElementById('optCouplePriority');
  const optDateStyleEl = document.getElementById('optDateStyle');

  // v2: reset persisted settings so new defaults take effect
  // (otherwise an older localStorage value like couplePriority=false makes layout look unchanged).
  const SETTINGS_KEY = 'genealogy_graph_demo_settings_v2';
  function loadSettings() {
    try {
      const raw = localStorage.getItem(SETTINGS_KEY);
      return raw ? JSON.parse(raw) : {};
    } catch {
      return {};
    }
  }
  function saveSettings(s) {
    try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); } catch {}
  }

  const settings = {
    // Defaults: Gramps-ish presentation.
    couplePriority: true,
    showIds: false,
    showDistance: false,
    dateStyle: 'full',
    ...loadSettings(),
  };

  // Force always-on behaviors (these are not user-toggles anymore).
  settings.showMarriage = true;
  settings.showDates = true;

  optCouplePriorityEl.checked = !!settings.couplePriority;
  optShowIdsEl.checked = !!settings.showIds;
  optShowDistanceEl.checked = !!settings.showDistance;
  optDateStyleEl.value = (settings.dateStyle === 'compact') ? 'compact' : 'full';

  function syncSettingsFromUi() {
    settings.couplePriority = !!optCouplePriorityEl.checked;
    settings.showIds = !!optShowIdsEl.checked;
    settings.showDistance = !!optShowDistanceEl.checked;
    settings.dateStyle = (optDateStyleEl.value === 'compact') ? 'compact' : 'full';

    // Keep always-on settings fixed.
    settings.showMarriage = true;
    settings.showDates = true;
    saveSettings(settings);
  }

  function setStatus(msg, isError=false) {
    statusEl.textContent = msg;
    statusEl.style.color = isError ? 'var(--danger)' : 'var(--muted)';
  }

  function setApiNotice(msg) {
    if (!msg) {
      apiNoticeEl.style.display = 'none';
      apiNoticeEl.textContent = '';
      return;
    }
    apiNoticeEl.style.display = 'block';
    apiNoticeEl.textContent = msg;
  }

  function updateApiNoticeFromPayload(payload) {
    const people = (payload?.nodes || []).filter(n => n?.type === 'person');
    if (!people.length) {
      setApiNotice(null);
      return;
    }

    const hasDates = people.some(p => ('birth' in p) || ('death' in p));
    const hasDistance = people.some(p => ('distance' in p));

    if (!hasDates) {
      setApiNotice('API not sending birth/death fields — restart the API to enable dates.');
      return;
    }
    if (settings.showDistance && !hasDistance) {
      setApiNotice('API not sending distance — restart the API to enable BFS hops.');
      return;
    }
    setApiNotice(null);
  }

  function normalizePersonIdFromGraphvizTitle(title) {
    if (!title) return null;
    const t = String(title).trim();
    return t;
  }

  const cyContainer = document.getElementById('cy');
  const cy = cytoscape({
    container: cyContainer,
    elements: [],
    style: [
      {
        selector: 'node',
        style: {
          'label': 'data(label)',
          'font-size': 10,
          'color': '#e8eefc',
          'text-valign': 'center',
          'text-halign': 'center',
          'text-wrap': 'wrap',
          'text-max-width': 110,
          'background-color': '#7aa2ff',
          'border-width': 1,
          'border-color': 'rgba(255,255,255,0.18)',
          'width': 120,
          'height': 46,
          'shape': 'round-rectangle',
          'padding': 8,
        }
      },
      {
        selector: 'node[type = "family"]',
        style: {
          'shape': 'ellipse',
          'width': 20,
          'height': 20,
          'background-color': '#9d7bff',
          'label': '',
          'border-color': 'rgba(255,255,255,0.28)'
        }
      },
      {
        selector: 'node[private = 1]',
        style: {
          'background-color': '#ffb86c',
          'color': '#10131a'
        }
      },
      {
        selector: 'node[type = "person"][gender = "M"]',
        style: {
          'background-color': '#7aa2ff'
        }
      },
      {
        selector: 'node[type = "person"][gender = "F"]',
        style: {
          'background-color': '#ff7ab6'
        }
      },
      {
        selector: 'node[type = "person"][gender = "U"]',
        style: {
          'background-color': '#b9c4dd'
        }
      },
      {
        selector: 'edge',
        style: {
          'curve-style': 'bezier',
          'line-color': 'rgba(255,255,255,0.28)',
          'width': 2,
          'target-arrow-shape': 'triangle',
          'target-arrow-color': 'rgba(255,255,255,0.28)',
          'arrow-scale': 0.7,
        }
      },
      {
        selector: 'edge[type = "partner"]',
        style: {
          'line-color': 'rgba(124,227,139,0.55)',
          'target-arrow-shape': 'none',
          'width': 1.5,
          'line-style': 'dashed'
        }
      },
      {
        selector: 'edge[type = "parent"]',
        style: {
          'line-color': 'rgba(122,162,255,0.52)',
          'target-arrow-color': 'rgba(122,162,255,0.52)'
        }
      },
      {
        selector: 'edge[type = "child"]',
        style: {
          'line-color': 'rgba(122,162,255,0.52)',
          'target-arrow-color': 'rgba(122,162,255,0.52)'
        }
      }
    ],
    wheelSensitivity: 0.2,
  });

  // Graphviz SVG panel styling.
  gvEl.style.height = '100%';
  gvEl.style.width = '100%';
  gvEl.style.borderRadius = '14px';
  gvEl.style.border = '1px solid var(--border)';
  gvEl.style.background = 'rgba(3, 6, 10, 0.65)';
  gvEl.style.boxShadow = 'var(--shadow)';
  // Don't use scrollbars for navigation; panning/zooming happens via SVG viewBox.
  gvEl.style.overflow = 'hidden';
  gvEl.style.position = 'relative';
  gvEl.style.touchAction = 'none';

  function nodeLabel(n) {
    if (n.type === 'family') return '';
    const name = n.display_name || '';
    const gid = n.gramps_id ? ` (${n.gramps_id})` : '';
    return `${name}${gid}`;
  }

  function normGender(g) {
    if (!g) return 'U';
    const s = String(g).trim();
    if (s === 'M' || s.toLowerCase() === 'male') return 'M';
    if (s === 'F' || s.toLowerCase() === 'female') return 'F';
    if (s === 'U' || s.toLowerCase() === 'unknown') return 'U';
    return 'U';
  }

  function makeElements(payload) {
    const nodes = [];
    const edges = [];

    for (const n of payload.nodes || []) {
      const isPrivate = (n.type === 'person' && n.display_name === 'Private');
      nodes.push({
        data: {
          id: n.id,
          type: n.type,
          label: nodeLabel(n),
          private: isPrivate ? 1 : 0,
          gramps_id: n.gramps_id || null,
          gender: (n.type === 'person') ? normGender(n.gender) : null,
        }
      });
    }

    let i = 0;
    for (const e of payload.edges || []) {
      edges.push({
        data: {
          id: `e${i++}`,
          source: e.from,
          target: e.to,
          type: e.type,
          role: e.role || null,
        }
      });
    }

    return nodes.concat(edges);
  }

  let _graphvizPromise = null;
  function getGraphviz() {
    if (!_graphvizPromise) {
      _graphvizPromise = Graphviz.load();
    }
    return _graphvizPromise;
  }

  function dotEscape(id) {
    // Always quote to keep Graphviz happy with underscores, etc.
    return `"${String(id).replaceAll('\\', '\\\\').replaceAll('"', '\\"')}"`;
  }

  function buildDotForFamily(payload) {
    const nodes = payload.nodes || [];
    const edges = payload.edges || [];

    const people = new Map();
    const families = new Set();
    const personDistance = new Map();
    for (const n of nodes) {
      if (n.type === 'person') {
        people.set(n.id, n);
        personDistance.set(n.id, (n.distance ?? null));
      }
      if (n.type === 'family') families.add(n.id);
    }

    const famParents = new Map();
    const famChildren = new Map();

    for (const e of edges) {
      if (e.type === 'parent') {
        const arr = famParents.get(e.to) || [];
        const role = (e.role || '').toString().trim().toLowerCase();
        arr.push({ pid: e.from, role: role || null });
        famParents.set(e.to, arr);
      } else if (e.type === 'child') {
        const arr = famChildren.get(e.from) || [];
        arr.push(e.to);
        famChildren.set(e.from, arr);
      }
    }

    const lines = [];
    lines.push('digraph gramps_like {');
    lines.push('  compound=true;');
    lines.push('  rankdir=TB;');
    lines.push('  splines=polyline;');
    // Slightly roomier defaults. Family separation is mainly handled by invisible
    // spacers in sibling rows further below.
    lines.push('  nodesep=0.32;');
    lines.push('  ranksep=0.90;');
    lines.push('  pad=0.2;');
    lines.push('  bgcolor="transparent";');
    lines.push('  node [fontname="Inter, Segoe UI, Arial", fontsize=10, style="filled", color="#2a3446", margin="0.08,0.06"];');
    lines.push('  edge [color="#556277", arrowsize=0.7, penwidth=1.2];');
    lines.push('  ordering=out;');

    const getCouple = (fid) => {
      const parents = famParents.get(fid) || [];
      const parentIds = [...new Set(parents.map(p => p.pid).filter(Boolean))];
      const hasTwoParents = parentIds.length >= 2;

      // Prefer explicit roles if present, otherwise take first two.
      const father = parents.find(p => p.role === 'father' || p.role === 'husband')?.pid;
      const mother = parents.find(p => p.role === 'mother' || p.role === 'wife')?.pid;
      if (father && mother) return { father, mother, hasTwoParents: true };
      if (hasTwoParents) return { father: parentIds[0], mother: parentIds[1], hasTwoParents: true };
      return { father: null, mother: null, hasTwoParents: false };
    };

    const birthSortKey = (pid) => {
      const p = people.get(pid);
      const t = p?.birth;
      if (!t) return Number.POSITIVE_INFINITY;

      // Prefer full ISO date for stable ordering.
      const iso = String(t).match(/\b(\d{4})-(\d{1,2})-(\d{1,2})\b/);
      if (iso) {
        const y = Number(iso[1]);
        const m = Number(iso[2]);
        const d = Number(iso[3]);
        if (Number.isFinite(y) && Number.isFinite(m) && Number.isFinite(d)) {
          return y * 10000 + m * 100 + d;
        }
      }

      const y = yearFromText(t);
      if (y && /^\d{4}$/.test(String(y))) return Number(y) * 10000;
      return Number.POSITIVE_INFINITY;
    };

    // Map person -> list of in-view spouses (derived from 2-parent families).
    const spouseOf = new Map();
    const addSpousePair = (a, b) => {
      if (!a || !b) return;
      if (!people.has(a) || !people.has(b)) return;
      spouseOf.set(a, [...(spouseOf.get(a) || []), b]);
      spouseOf.set(b, [...(spouseOf.get(b) || []), a]);
    };

    const htmlEscape = (s) => {
      if (s === null || s === undefined) return '';
      return String(s)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;');
    };

    const escLabelLine = (s) => String(s ?? '').replaceAll('\\', '\\\\').replaceAll('"', '\\"');

    const splitDisplayNameFallback = (displayName) => {
      const raw = String(displayName || '').trim();
      if (!raw) return { given: '', surname: '' };

      const parts = raw.split(/\s+/g);
      if (parts.length <= 1) return { given: raw, surname: '' };

      // Try to keep Dutch/German surname particles with the surname.
      const particleSet = new Set([
        'van', 'von', 'de', 'den', 'der', 'ten', 'ter', 'te',
        'v.d.', 'v/d', 'vd', 'v.d', 'v',
        'zu', 'zum', 'zur',
      ]);

      const surnameTokens = [parts[parts.length - 1]];
      for (let i = parts.length - 2; i >= 0; i--) {
        const t = parts[i].toLowerCase();
        if (particleSet.has(t)) {
          surnameTokens.unshift(parts[i]);
          continue;
        }
        break;
      }

      const given = parts.slice(0, parts.length - surnameTokens.length).join(' ');
      const surname = surnameTokens.join(' ');
      return { given, surname };
    };

    const deriveSurnameFromDisplayName = (displayName, givenName, fallbackSurname) => {
      const dn = String(displayName || '').trim();
      const gn = String(givenName || '').trim();
      const fs = String(fallbackSurname || '').trim();
      if (!dn) return fs;

      // If we have given_name, prefer taking the remainder of display_name.
      // This tends to preserve particles like "van" that are often not stored in surname.
      if (gn) {
        const dnNorm = dn.replace(/\s+/g, ' ').toLowerCase();
        const gnNorm = gn.replace(/\s+/g, ' ').toLowerCase();
        if (dnNorm.startsWith(gnNorm)) {
          const remainder = dn.slice(gn.length).trim();
          if (remainder) return remainder;
        }
      }

      // Fall back to either stored surname or heuristic split.
      if (fs) return fs;
      const fb = splitDisplayNameFallback(dn);
      return fb.surname;
    };

    const MONTHS_NL = {
      1: 'januari',
      2: 'februari',
      3: 'maart',
      4: 'april',
      5: 'mei',
      6: 'juni',
      7: 'juli',
      8: 'augustus',
      9: 'september',
      10: 'oktober',
      11: 'november',
      12: 'december',
    };

    const normalizeWs = (s) => String(s).trim().replace(/\s+/g, ' ');

    const yearFromText = (t) => {
      if (!t) return null;
      const m = String(t).match(/\b(1[0-9]{3}|20[0-9]{2})\b/);
      return m ? m[1] : null;
    };

    const extractFullDateOrYear = (t) => {
      if (!t) return null;
      const s = normalizeWs(t);

      // ISO yyyy-mm-dd (Gramps exports often look like this)
      const iso = s.match(/\b(\d{4})-(\d{1,2})-(\d{1,2})\b/);
      if (iso) {
        const year = iso[1];
        const monthNum = Number(iso[2]);
        const day = Number(iso[3]);
        const month = MONTHS_NL[monthNum] || String(monthNum);
        if (
          Number.isFinite(day) && day >= 1 && day <= 31 &&
          Number.isFinite(monthNum) && monthNum >= 1 && monthNum <= 12
        ) {
          return `${day} ${month} ${year}`;
        }
      }

      // dd-mm-yyyy / dd/mm/yyyy / dd.mm.yyyy
      const n = s.match(/\b(\d{1,2})[\/.\-](\d{1,2})[\/.\-](\d{4})\b/);
      if (n) {
        const day = Number(n[1]);
        const monthNum = Number(n[2]);
        const year = n[3];
        const month = MONTHS_NL[monthNum] || String(monthNum);
        if (Number.isFinite(day) && day >= 1 && day <= 31 && Number.isFinite(monthNum) && monthNum >= 1 && monthNum <= 12) {
          return `${day} ${month} ${year}`;
        }
      }

      // dd Month yyyy (month word)
      const w = s.match(/\b(\d{1,2})\s+([A-Za-zÀ-ÿ]+)\s+(\d{4})\b/);
      if (w) {
        const day = Number(w[1]);
        const monthWord = String(w[2]).toLowerCase();
        const year = w[3];
        if (Number.isFinite(day) && day >= 1 && day <= 31) {
          return `${day} ${monthWord} ${year}`;
        }
      }

      const y = yearFromText(s);
      return y ? y : null;
    };

    const formatDateLine = (t, symbol) => {
      const v = extractFullDateOrYear(t);
      if (!v) return null;
      return `${symbol} ${String(v).toLowerCase()}`;
    };

    // Nodes: one node per person, one hub per family.
    for (const [pid, p] of people.entries()) {
      const isPrivate = p.display_name === 'Private';
      const g = normGender(p.gender);

      // Gramps-like fixed-size card
      // - light grey body
      // - colored top rim by gender
      // - stable vertical layout (name + birth + death)
      let rim = '#7aa2ff';
      if (g === 'F') rim = '#ff7ab6';
      if (g === 'U') rim = '#b9c4dd';
      if (isPrivate) rim = '#ffb86c';

      let given = '';
      let surname = '';
      if (!isPrivate) {
        given = (p.given_name || '').trim();
        surname = deriveSurnameFromDisplayName(p.display_name, given, p.surname);
        if (!given) {
          const fb = splitDisplayNameFallback(p.display_name);
          given = fb.given;
          if (!surname) surname = fb.surname;
        }
      }

      const nameLine1 = isPrivate
        ? 'Private'
        : ((given || p.display_name || p.gramps_id || pid).trim());
      const nameLine2 = (!isPrivate && surname) ? surname : '';

      const birthLine = (!isPrivate && settings.dateStyle === 'compact')
        ? (() => {
            const by = yearFromText(p.birth);
            return by ? `*${by}` : null;
          })()
        : (!isPrivate ? formatDateLine(p.birth, '*') : null);

      const deathLine = (!isPrivate && settings.dateStyle === 'compact')
        ? (() => {
            const dy = yearFromText(p.death);
            // Compact still uses dagger.
            return dy ? `†${dy}` : null;
          })()
        : (!isPrivate ? formatDateLine(p.death, '+') : null);

      const footerBits = [];
      if (!isPrivate && settings.showDistance && (p.distance ?? null) !== null) {
        footerBits.push(`d=${p.distance}`);
      }
      if (settings.showIds && !isPrivate && p.gramps_id) {
        footerBits.push(p.gramps_id);
      }

      const footer = footerBits.length ? htmlEscape(footerBits.join(' · ')) : '';

      // Robust fixed-size node with a “rim” via gradient fill.
      // Graphviz supports gradients using a ':' color list; many builds also support
      // stops like 'color;0.12:color'. If stops aren't supported, it will degrade to a gradient.
      const bodyBg = '#cccccc'; // ~20% black
      const labelLines = [nameLine1, nameLine2, birthLine || '', deathLine || '']
        .filter(v => v && String(v).trim().length)
        .map(escLabelLine);

      // Use Graphviz's left-justified newline marker (\l).
      // Trailing \l keeps the last line left-aligned too.
      const label = labelLines.join('\\l') + '\\l';

      const fill = `${rim};0.12:${bodyBg}`;
      lines.push(
        `  ${dotEscape(pid)} [` +
        `shape=box, style="rounded,filled", fixedsize=true, width=1.60, height=1.10, ` +
        `fillcolor="${fill}", gradientangle=270, ` +
        `color="#9aa4b5", penwidth=1.1, ` +
        `fontname="Inter, Segoe UI, Arial", fontsize=10, fontcolor="#0b0f16", ` +
        `labeljust=l, labelloc=c, margin="0.10,0.08", ` +
        `label="${label}"` +
        `];`
      );
    }
    for (const fid of families) {
      const m = '⚭';
      lines.push(
        `  ${dotEscape(fid)} [shape=circle, width=0.24, height=0.24, fixedsize=true, fillcolor="#9d7bff", fontcolor="#0b0f16", fontsize=12, penwidth=1.2, label="${m}"];`
      );
    }

    // Collect all spouses (people in a 2-parent family).
    const spouseSet = new Set();
    for (const fid of families) {
      const { father, mother, hasTwoParents } = getCouple(fid);
      if (hasTwoParents && father && mother) {
        spouseSet.add(father);
        spouseSet.add(mother);
        addSpousePair(father, mother);
      }
    }

    // Build birth-family lookup (child -> families where they're a child).
    const birthFamiliesByPerson = new Map();
    for (const e of edges) {
      if (e.type !== 'child') continue;
      // e.from = family, e.to = child
      const childId = e.to;
      const famId = e.from;
      if (!childId || !famId) continue;
      const arr = birthFamiliesByPerson.get(childId) || [];
      arr.push(famId);
      birthFamiliesByPerson.set(childId, arr);
    }

    const distKey = (pid) => {
      const d = personDistance.get(pid);
      return (d === null || d === undefined) ? 1e9 : Number(d);
    };

    // Couple adjacency across the whole view:
    // A spouse should appear adjacent to their partner in *one* sibling row.
    // If we let the same person be forced into multiple sibling rows, DOT will split
    // rows and produce strange interleavings.
    //
    // Strategy:
    // - For each family sibling row, consider attaching in-view spouses next to children.
    // - Choose exactly one attachment row per spouse (best/closest partner by BFS distance).
    // - Remove the attached spouse from their own birth-family sibling row(s) in this view.
    const spouseAttachmentTargetByPerson = new Map(); // person -> familyId where they are attached as spouse
    const spouseAttachmentByFamily = new Map(); // familyId -> Map(childId -> spouseId)

    const attachmentCandidatesBySpouse = new Map();
    for (const fid of families) {
      const rawChildren = famChildren.get(fid) || [];
      const childSet = new Set(rawChildren);

      for (const childId of rawChildren) {
        const spouses = spouseOf.get(childId) || [];
        for (const spouseId of spouses) {
          if (!spouseId) continue;
          if (!people.has(spouseId)) continue;
          // Don't attach if the spouse is also a sibling in this same row.
          if (childSet.has(spouseId)) continue;

          const arr = attachmentCandidatesBySpouse.get(spouseId) || [];
          arr.push({
            spouseId,
            familyId: fid,
            partnerChildId: childId,
            score: distKey(childId),
          });
          attachmentCandidatesBySpouse.set(spouseId, arr);
        }
      }
    }

    for (const [spouseId, candidates] of attachmentCandidatesBySpouse.entries()) {
      if (!candidates.length) continue;
      candidates.sort((a, b) => {
        if (a.score !== b.score) return a.score - b.score;
        if (a.familyId !== b.familyId) return String(a.familyId).localeCompare(String(b.familyId));
        return String(a.partnerChildId).localeCompare(String(b.partnerChildId));
      });

      const best = candidates[0];
      spouseAttachmentTargetByPerson.set(spouseId, best.familyId);

      const perFam = spouseAttachmentByFamily.get(best.familyId) || new Map();
      // One spouse per child for readability.
      if (!perFam.has(best.partnerChildId)) perFam.set(best.partnerChildId, spouseId);
      spouseAttachmentByFamily.set(best.familyId, perFam);
    }

    // Couple priority: keep spouses adjacent.
    for (const fid of families) {
      const { father, mother, hasTwoParents } = getCouple(fid);
      if (hasTwoParents && father && mother) {
        // Gramps Web style: use a per-family cluster to keep the couple cohesive.
        // This is the single most effective nudge DOT has for spouse adjacency.
        // We keep it invisible (no box) and only use it as a layout hint.
        lines.push(`  subgraph ${dotEscape('cluster_couple_' + fid)} {`);
        lines.push('    cluster=true;');
        lines.push('    style=invis;');
        lines.push('    color=white;');
        lines.push('    label=".";');
        // Encourage both parents to sit on the same generation row.
        lines.push('    rank=same;');
        lines.push(`    ${dotEscape(father)}; ${dotEscape(mother)};`);
        lines.push('  }');

        const gf = (people.get(father)?.gender || '').toString().trim().toUpperCase();
        const gm = (people.get(mother)?.gender || '').toString().trim().toUpperCase();

        // Hard glue: keep couples adjacent as much as DOT allows.
        // Use a very high weight and minlen=0 to strongly discourage any node in-between.
        // constraint=false so we don't fight the vertical generational ranking.
        let left = father;
        let right = mother;
        if (gf === 'F' && gm === 'M') {
          left = mother;
          right = father;
        }
        lines.push(`  ${dotEscape(left)} -> ${dotEscape(right)} [style=invis, weight=20000, minlen=0, constraint=false, dir=none];`);

        // Family node below couple.
        lines.push(`  ${dotEscape(father)} -> ${dotEscape(fid)} [arrowhead=none, constraint=true, weight=8, minlen=1];`);
        lines.push(`  ${dotEscape(mother)} -> ${dotEscape(fid)} [arrowhead=none, constraint=true, weight=8, minlen=1];`);
      }
    }

    // Keep siblings on the same rank (row) beneath their family.
    for (const fid of families) {
      const rawChildren = famChildren.get(fid) || [];
      // Sibling row ordering:
      // - siblings sorted by birth
      // - if a sibling has an in-view spouse, keep the couple adjacent
      // - within a couple: man left, woman right (when gender is known)
      // Also: if someone is being "pulled" into another row as an attached spouse,
      // remove them from their own sibling row in this view to avoid contradictory
      // rank constraints.
      const children = rawChildren.filter(cid => {
        const target = spouseAttachmentTargetByPerson.get(cid);
        return !target || target === fid;
      });

      if (children.length >= 1) {
        // Add an invisible spacer node at the end of each sibling group.
        // This creates a visible gap between sibling groups from adjacent families.
        const sepId = `${fid}__sep`;
        lines.push(`  ${dotEscape(sepId)} [shape=point, style=invis, width=0.80, height=0.02, fixedsize=true, label=""];`);

        const attachments = spouseAttachmentByFamily.get(fid) || new Map();
        const blocks = children.map((cid) => {
          const spouse = attachments.get(cid) || null;
          return {
            child: cid,
            spouse,
            isMarried: !!spouse,
            key: birthSortKey(cid),
          };
        });

        blocks.sort((a, b) => {
          if (a.key !== b.key) return a.key - b.key;
          return String(a.child).localeCompare(String(b.child));
        });

        const ordered = blocks;

        const genderOf = (pid) => {
          const g = (people.get(pid)?.gender || '').toString().trim().toUpperCase();
          return (g === 'M' || g === 'F') ? g : 'U';
        };

        // Flatten into node order for this sibling row.
        const rowNodes = [];
        const coupleGlueEdges = [];
        for (const b of ordered) {
          if (!settings.couplePriority || !b.spouse) {
            rowNodes.push(b.child);
            continue;
          }

          // Place the couple as (M,F) when possible; otherwise keep child first.
          const gChild = genderOf(b.child);
          const gSpouse = genderOf(b.spouse);

          if (gChild === 'F' && gSpouse === 'M') {
            rowNodes.push(b.spouse);
            rowNodes.push(b.child);
            coupleGlueEdges.push([b.spouse, b.child]);
          } else {
            rowNodes.push(b.child);
            rowNodes.push(b.spouse);
            coupleGlueEdges.push([b.child, b.spouse]);
          }
        }

        // Keep the sibling group and its spacer on the same row.
        // Using a cluster (cluster_ prefix) nudges DOT to keep the group cohesive
        // and reduces "interleaving" with other families in the same generation.
        lines.push(`  subgraph ${dotEscape('cluster_children_' + fid)} {`);
        lines.push('    style=invis;');
        lines.push('    rank=same;');
        lines.push(`    ${rowNodes.map(dotEscape).join('; ')}; ${dotEscape(sepId)};`);
        lines.push('  }');

        // Invisible ordering edges to keep the row stable (avoid interleaving).
        // constraint=false so we don't change generations; high weight influences ordering.
        if (rowNodes.length >= 2) {
          for (let i = 0; i < rowNodes.length - 1; i++) {
            lines.push(`  ${dotEscape(rowNodes[i])} -> ${dotEscape(rowNodes[i + 1])} [style=invis, weight=160, constraint=false, dir=none];`);
          }
        }

        // Extra hard glue for couples inside this sibling row.
        for (const [l, r] of coupleGlueEdges) {
          lines.push(`  ${dotEscape(l)} -> ${dotEscape(r)} [style=invis, weight=20000, minlen=0, constraint=false, dir=none];`);
        }
        if (rowNodes.length >= 1) {
          lines.push(`  ${dotEscape(rowNodes[rowNodes.length - 1])} -> ${dotEscape(sepId)} [style=invis, weight=160, constraint=false, dir=none];`);
        }
      }
    }

    // Edges
    for (const e of edges) {
      if (e.type === 'parent') {
        const fid = e.to;
        const pid = e.from;
        const { hasTwoParents } = getCouple(fid);
        // For 2-parent families we already added the strong parent->family edges above.
        if (!hasTwoParents) {
          lines.push(`  ${dotEscape(pid)} -> ${dotEscape(fid)} [arrowhead=none, constraint=true, weight=3, minlen=1];`);
        }
      } else if (e.type === 'child') {
        // Family->child edges define the generation ranks.
        // Higher weight keeps children closer to their own family hub, which helps
        // prevent unrelated nodes from visually "splitting" a sibling row.
        lines.push(`  ${dotEscape(e.from)} -> ${dotEscape(e.to)} [arrowhead=none, constraint=true, weight=12, minlen=2];`);
      }
    }

    lines.push('}');
    return lines.join('\n');
  }

  function showCytoscape() {
    gvEl.style.display = 'none';
    cyContainer.style.display = 'block';
    cy.resize();
  }

  function showGraphviz() {
    cyContainer.style.display = 'none';
    gvEl.style.display = 'block';
  }

  function enableSvgPanZoom(svg, {container} = {}) {
    // Minimal pan/zoom for inline SVG via viewBox.
    // Works in normal browsers + VS Code Simple Browser.
    const ensureViewBox = () => {
      let vb = svg.viewBox?.baseVal;
      if (vb && Number.isFinite(vb.width) && vb.width > 0 && Number.isFinite(vb.height) && vb.height > 0) {
        return vb;
      }
      // Ensure a viewBox exists.
      const w = Number(svg.getAttribute('width')) || 1000;
      const h = Number(svg.getAttribute('height')) || 800;
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      return svg.viewBox.baseVal;
    };

    const vb0 = ensureViewBox();

    const state = {
      x: vb0.x,
      y: vb0.y,
      w: vb0.width,
      h: vb0.height,
      dragging: false,
      lastX: 0,
      lastY: 0,
      orig: { x: vb0.x, y: vb0.y, w: vb0.width, h: vb0.height },
    };

    const apply = () => {
      svg.setAttribute('viewBox', `${state.x} ${state.y} ${state.w} ${state.h}`);
    };

    const wheel = (e) => {
      e.preventDefault();
      const rect = (container || svg).getBoundingClientRect();
      const px = (e.clientX - rect.left) / rect.width;
      const py = (e.clientY - rect.top) / rect.height;

      const zoom = Math.exp((e.deltaY > 0 ? 1 : -1) * 0.12);
      const newW = state.w * zoom;
      const newH = state.h * zoom;

      // Zoom towards pointer.
      state.x = state.x + (state.w - newW) * px;
      state.y = state.y + (state.h - newH) * py;
      state.w = newW;
      state.h = newH;
      apply();
    };

    // Pointer-captured panning so drag feels 1:1 (in screen pixels) regardless of zoom.
    const down = (e) => {
      // Don't start panning when clicking a node.
      if (e.target && e.target.closest && e.target.closest('g.node')) return;
      if (e.button !== 0) return;
      e.preventDefault();
      state.dragging = true;
      state.lastX = e.clientX;
      state.lastY = e.clientY;
      (container || svg).style.cursor = 'grabbing';
      if (typeof (container || svg).setPointerCapture === 'function') {
        try { (container || svg).setPointerCapture(e.pointerId); } catch (_) {}
      }
      document.body.style.userSelect = 'none';
    };

    const move = (e) => {
      if (!state.dragging) return;
      e.preventDefault();
      const rect = (container || svg).getBoundingClientRect();

      const dxPx = e.clientX - state.lastX;
      const dyPx = e.clientY - state.lastY;
      state.lastX = e.clientX;
      state.lastY = e.clientY;

      // Convert pixels -> viewBox units so the perceived movement is exactly dxPx/dyPx.
      state.x -= dxPx * (state.w / rect.width);
      state.y -= dyPx * (state.h / rect.height);
      apply();
    };

    const up = (e) => {
      if (!state.dragging) return;
      e.preventDefault();
      state.dragging = false;
      (container || svg).style.cursor = 'grab';
      document.body.style.userSelect = '';
      if (typeof (container || svg).releasePointerCapture === 'function') {
        try { (container || svg).releasePointerCapture(e.pointerId); } catch (_) {}
      }
    };

    const target = container || svg;
    target.style.cursor = 'grab';
    target.addEventListener('wheel', wheel, { passive: false });
    target.addEventListener('pointerdown', down);
    target.addEventListener('pointermove', move);
    target.addEventListener('pointerup', up);
    target.addEventListener('pointercancel', up);

    return {
      reset: () => {
        state.x = state.orig.x;
        state.y = state.orig.y;
        state.w = state.orig.w;
        state.h = state.orig.h;
        apply();
      }
    };
  }

  async function renderGraphvizSvg(payload) {
    const dot = buildDotForFamily(payload);
    const gv = await getGraphviz();
    const svgText = (typeof gv.layout === 'function')
      ? gv.layout(dot, 'svg', 'dot')
      : gv.dot(dot);

    gvEl.innerHTML = svgText;

    // Inject lightweight styling for nicer Gramps-like feel.
    const style = document.createElement('style');
    style.textContent = `
      svg { font-family: var(--sans); }
      svg text { fill: #0b0f16; }
      g.node:hover polygon, g.node:hover rect, g.node:hover ellipse {
        filter: drop-shadow(0 2px 8px rgba(122,162,255,0.20));
      }
      g.edge path {
        stroke-linecap: round;
        stroke-linejoin: round;
      }
    `;
    gvEl.prepend(style);

    const svg = gvEl.querySelector('svg');
    if (svg) {
      // Make the SVG behave like a canvas inside the panel.
      svg.style.display = 'block';
      svg.style.maxWidth = 'none';
      svg.style.height = '100%';
      svg.style.width = '100%';
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      const personMetaById = new Map();
      for (const n of payload?.nodes || []) {
        if (n?.type !== 'person') continue;
        const isPrivate = (n.display_name === 'Private');
        personMetaById.set(String(n.id), {
          gender: normGender(n.gender),
          isPrivate,
        });
      }

      postProcessGraphvizSvg(svg, { personMetaById });

      // Add pan/zoom.
      gvPanZoom = enableSvgPanZoom(svg, { container: gvEl });
    }


  function postProcessGraphvizSvg(svg, { personMetaById } = {}) {
    const nodes = svg.querySelectorAll('g.node');
    let processed = 0;
    for (const node of nodes) {
      // Skip non-person nodes (family hubs are circles/ellipses)
      if (node.querySelector('ellipse')) continue;

      // Add a curved, gender-colored “rim” on top of each person card.
      // We do this in SVG (not DOT) because DOT gradients can only be straight.
      try {
        const title = node.querySelector('title')?.textContent?.trim();
        const pid = normalizePersonIdFromGraphvizTitle(title);

        const meta = pid ? personMetaById?.get(String(pid)) : null;
        if (pid && meta && !node.querySelector('[data-rim="1"]')) {
          let rim = '#7aa2ff';
          if (meta.gender === 'F') rim = '#ff7ab6';
          if (meta.gender === 'U') rim = '#b9c4dd';
          if (meta.isPrivate) rim = '#ffb86c';

          const shape = node.querySelector('path') || node.querySelector('polygon') || node.querySelector('rect');
          if (shape && typeof shape.getBBox === 'function') {
            const bb = shape.getBBox();
            const x0 = bb.x;
            const y0 = bb.y;
            const w = bb.width;
            const h = bb.height;
            const x1 = x0 + w;

            const rimH = Math.max(7, Math.min(14, h * 0.18));
            const yRim = y0 + rimH;
            const curve = Math.max(2, Math.min(8, rimH * 0.55));
            const corner = Math.max(3, Math.min(10, Math.min(w, h) * 0.12));
            const xMid = x0 + (w / 2);

            const d = [
              `M ${x0 + corner} ${y0}`,
              `H ${x1 - corner}`,
              `A ${corner} ${corner} 0 0 1 ${x1} ${y0 + corner}`,
              `V ${yRim}`,
              `Q ${xMid} ${yRim + curve} ${x0} ${yRim}`,
              `V ${y0 + corner}`,
              `A ${corner} ${corner} 0 0 1 ${x0 + corner} ${y0}`,
              'Z'
            ].join(' ');

            const ns = 'http://www.w3.org/2000/svg';
            const rimPath = document.createElementNS(ns, 'path');
            rimPath.setAttribute('d', d);
            rimPath.setAttribute('fill', rim);
            rimPath.setAttribute('stroke', 'none');
            rimPath.setAttribute('opacity', '1');
            rimPath.setAttribute('data-rim', '1');

            const rimEdge = document.createElementNS(ns, 'path');
            rimEdge.setAttribute('d', `M ${x1} ${yRim} Q ${xMid} ${yRim + curve} ${x0} ${yRim}`);
            rimEdge.setAttribute('fill', 'none');
            rimEdge.setAttribute('stroke', 'rgba(255,255,255,0.35)');
            rimEdge.setAttribute('stroke-width', '0.8');
            rimEdge.setAttribute('stroke-linecap', 'round');
            rimEdge.setAttribute('stroke-linejoin', 'round');
            rimEdge.setAttribute('data-rim', '1');

            // Insert before the first text element so it doesn't cover labels.
            const firstText = node.querySelector('text');
            if (firstText) {
              node.insertBefore(rimEdge, firstText);
              node.insertBefore(rimPath, rimEdge);
            } else {
              node.appendChild(rimPath);
              node.appendChild(rimEdge);
            }
          }
        }
      } catch (_) {
        // Best-effort only; keep the graph usable even if post-processing fails.
      }

      const texts = Array.from(node.querySelectorAll('text'));
      if (!texts.length) continue;

      // Sort by y so “first” matches the top line.
      texts.sort((a, b) => (Number(a.getAttribute('y')) || 0) - (Number(b.getAttribute('y')) || 0));

      // Bold the name (given + surname): first two lines.
      for (let i = 0; i < Math.min(2, texts.length); i++) {
        texts[i].style.fontWeight = '700';
        texts[i].setAttribute('font-weight', '700');
      }

      processed += 1;
    }

    if (processed > 0) {
      // Small signal to confirm JS is running and SVG post-processing applied.
      // (Helps when the browser is serving a cached version of this page.)
      setStatus(`Rendered Graphviz (styled ${processed} person nodes).`);
    }
  }
    // Basic click handling: update status when you click a node.
    gvEl.querySelectorAll('g.node').forEach(g => {
      g.style.cursor = 'pointer';
      g.addEventListener('click', () => {
        const title = g.querySelector('title')?.textContent?.trim();
        const pid = normalizePersonIdFromGraphvizTitle(title);
        if (!pid) return;

        // Navigate like Gramps: click a person to re-center graph.
        if (/^I\d+$/i.test(String(pid))) {
          personIdEl.value = pid;
          setStatus(`Centering on ${pid}...`);
          loadGraph();
          return;
        }
        setStatus(`Selected node: ${pid}`);
      });
    });
  }

  function runLayout(layout) {
    // Try to keep it Gramps-ish:
    // - family layout: breadthfirst tends to make nice generations when edges are directed
    // - direct layout: cose is usually OK but can tangle partner edges; breadthfirst is still readable
    const name = (layout === 'family') ? 'dagre' : 'cose';

    const opts = (name === 'dagre')
      ? {
          name,
          rankDir: 'TB',
          nodeSep: 20,
          edgeSep: 10,
          rankSep: 60,
          padding: 30,
          animate: true,
          fit: true,
        }
      : {
          name,
          animate: true,
          fit: true,
          padding: 30,
          nodeRepulsion: 7000,
          idealEdgeLength: 110,
          edgeElasticity: 0.2,
        };

    cy.layout(opts).run();
  }

  async function loadGraph() {
    const personId = personIdEl.value.trim();
    const depth = Number(depthEl.value);
    const maxNodes = Number(maxNodesEl.value);
    const uiLayout = layoutEl.value;
    const apiLayout = (uiLayout === 'direct') ? 'direct' : 'family';

    if (!personId) {
      setStatus('Enter a person id like I0001.', true);
      return;
    }

    const url = new URL('/graph/neighborhood', window.location.origin);
    url.searchParams.set('id', personId);
    url.searchParams.set('depth', String(depth));
    url.searchParams.set('max_nodes', String(maxNodes));
    url.searchParams.set('layout', apiLayout);

    setStatus(`Loading ${url.pathname}?${url.searchParams.toString()}`);

    try {
      const resp = await fetch(url.toString());
      if (!resp.ok) {
        const text = await resp.text();
        throw new Error(`HTTP ${resp.status}: ${text}`);
      }
      const payload = await resp.json();

      updateApiNoticeFromPayload(payload);

      if (uiLayout === 'graphviz') {
        showGraphviz();
        setStatus('Rendering Graphviz (dot) SVG...');
        await renderGraphvizSvg(payload);
        setStatus(`Loaded ${payload.nodes?.length ?? 0} nodes, ${payload.edges?.length ?? 0} edges (${uiLayout}).`);
        return;
      }

      showCytoscape();
      cy.elements().remove();
      cy.add(makeElements(payload));
      runLayout(uiLayout);
      setStatus(`Loaded ${payload.nodes?.length ?? 0} nodes, ${payload.edges?.length ?? 0} edges (${uiLayout}).`);
    } catch (err) {
      console.error(err);
      setStatus(String(err), true);
    }
  }


  document.getElementById('loadBtn').addEventListener('click', loadGraph);
  document.getElementById('fitBtn').addEventListener('click', () => {
    if (layoutEl.value === 'graphviz') {
      gvPanZoom?.reset?.();
      return;
    }
    cy.fit(undefined, 40);
  });
  document.getElementById('toggleBtn').addEventListener('click', () => {
    layoutEl.value = (layoutEl.value === 'family') ? 'direct' : 'family';
    loadGraph();
  });
  document.getElementById('pngBtn').addEventListener('click', () => {
    if (layoutEl.value === 'graphviz') {
      const svg = gvEl.querySelector('svg');
      if (!svg) return;
      const svgText = new XMLSerializer().serializeToString(svg);
      const blob = new Blob([svgText], { type: 'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `genealogy_graph_${layoutEl.value}_${personIdEl.value.trim() || 'id'}.svg`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      return;
    }
    const png = cy.png({ scale: 2, full: true, bg: 'rgba(11,15,22,1)' });
    const a = document.createElement('a');
    a.href = png;
    a.download = `genealogy_graph_${layoutEl.value}_${personIdEl.value.trim() || 'id'}.png`;
    a.click();
  });

  for (const el of [optCouplePriorityEl, optShowIdsEl, optShowDistanceEl, optDateStyleEl]) {
    el.addEventListener('change', () => {
      syncSettingsFromUi();
      if (layoutEl.value === 'graphviz') {
        loadGraph();
      }
    });
  }

  function syncExportButtonLabel() {
    const btn = document.getElementById('pngBtn');
    btn.textContent = (layoutEl.value === 'graphviz') ? 'Export SVG' : 'Export PNG';
  }

  layoutEl.addEventListener('change', () => {
    syncExportButtonLabel();
    loadGraph();
  });

  syncExportButtonLabel();

  cy.on('tap', 'node', (evt) => {
    const n = evt.target.data();
    const gid = n.gramps_id ? ` (${n.gramps_id})` : '';
    setStatus(`Selected ${n.type}: ${n.id}${gid}`);
  });

  // Auto-load once.
  // Default to the Gramps-style layout.
  layoutEl.value = 'graphviz';
  loadGraph();
</script>
</body>
</html>
